
{% for type_ in types %}
{{ type_ }}SelectionType = TypeVar('{{ type_ }}SelectionType')


class {{ type_ }}Field:
    def __init__(self, field_name: str, field_type: Union[Type, str]):
        if isinstance(field_type, str):
            field_type = ForwardRef(field_type)
        self.field_name = field_name
        self.field_type = field_type

    def __getattr__(self, name):
        if name == 'select':
            return self.get_type()(self.field_name).select

    def get_type(self):
        if isinstance(self.field_type, ForwardRef):
            return get_type_hints(self.field_type, globals(), locals())
        return self.field_type


@dataclass
class {{ type_ }}(metaclass=GeneratedType):
    {% for field_name, field in type_.fields.items() -%}
        {{ underscore(field_name) }}{{ ': ' }}
        {%- if get_type(field.type, constants.selection).rstrip(']').endswith(constants.selection.value) -%}
            {%- set f_type = get_type(field.type, constants.selection.value + '[' + type_.name + 'Field]', enquote=True, strip_class=True) -%}
            {{ f_type }} = {{ type_ }}Field('{{ field_name }}', {{ f_type }})
        {%- else %}{{ type_ }}Field = {{ type_ }}Field('{{ field_name }}', {{ get_type(field.type, constants.selection, strip_class=True) }}){% endif %}
    {% endfor %}

class {{ type_ }}Selection(Generic[{{ type_ }}SelectionType]):
    def __init__(self, calling_field: str):
        self.calling_field = calling_field
        self.finish_select = lambda: None

    {% set field_type = get_type(type_, strip_class=True, suffix='Field') -%}
    def select(self, *fields: {{ field_type }}) -> {{ type_ }}SelectionType:
        graphql_fields = [f.field_name for f in fields if isinstance(f, {{ field_type }})]
        nested_selects = list(map(lambda f: lambda s: f.finish_select(getattr(s.{{ get_type(type_, strip_class=True) }}, f.calling_field), s),  # type: ignore
                                  filter(lambda f: not isinstance(f, {{ field_type }}), fields)))
        self.finish_select = partial_select(list(map(lambda f: lambda s: getattr(s.{{ get_type(type_, strip_class=True) }}, f), graphql_fields)) + nested_selects)
        return self

{% endfor %}


{%- for type_ in union_types %}
{%- set sub_types = get_union_types(type_) %}
{{ type_ }}FieldType = TypeVar('{{ type_ }}FieldType')
{{ type_ }}SelectionType = TypeVar('{{ type_ }}SelectionType')


class {{ type_ }}Field:
    def __init__(self, field_name: str, field_type: Union[Type, str]):
        if isinstance(field_type, str):
            field_type = ForwardRef(field_type)
        self.field_name = field_name
        self.field_type = field_type

    def __getattr__(self, name):
        if name == 'select':
            return self.get_type()(self.field_name).select

    def get_type(self):
        if isinstance(self.field_type, ForwardRef):
            return get_type_hints(self.field_type, globals(), locals())
        return self.field_type


@dataclass
class {{ type_ }}(metaclass=GeneratedUnionType):
    class OnFragment:
        def __init__(self, on_type: {{ sub_types }}):
            self.on_type = on_type

    {%- for sub_type in type_.types %}

    @staticmethod
    @overload
    def on(on_type: Type[{{ sub_type }}]) -> {{ sub_type }}Selection[Any]: ...
    {%- endfor %}

    @staticmethod
    def on(on_type: Union[{% for sub_type in type_.types %}Type[{{ sub_type }}]{% if not loop.last %}, {% endif %}{% endfor %}]):
        return {
            {%- for sub_type in type_.types %}
            {{ sub_type }}: {{ sub_type }}Selection[Any]
            {%- if not loop.last %},{% endif -%}
            {% endfor %}
        }[on_type](None)

{% endfor %}

{%- for type_ in interface_types %}
{%- set sub_types = get_interface_types(type_) %}
{{ type_ }}FieldType = TypeVar('{{ type_ }}FieldType')
{{ type_ }}SelectionType = TypeVar('{{ type_ }}SelectionType')


class {{ type_ }}Selection(Generic[{{ type_ }}SelectionType]):
    def __init__(self, calling_field: str):
        self.calling_field = calling_field
        self.finish_select = lambda: None

    {% set field_type = get_type(type_, strip_class=True, suffix='Field') -%}
    def select(self, *fields: '{{ field_type }}') -> {{ type_ }}SelectionType:
        graphql_fields = [f.field_name for f in fields if isinstance(f, {{ field_type }})]
        nested_selects = list(map(lambda f: lambda s: f.finish_select(getattr(s.{{ get_type(type_, strip_class=True) }}, f.calling_field), s),  # type: ignore
                                  filter(lambda f: not isinstance(f, {{ field_type }}), fields)))
        self.finish_select = partial_select(list(map(lambda f: lambda s: getattr(s.{{ get_type(type_, strip_class=True) }}, f), graphql_fields)) + nested_selects)
        return self


class {{ type_ }}Field:
    def __init__(self, field_name: str, field_type: Union[Type, str]):
        if isinstance(field_type, str):
            field_type = ForwardRef(field_type)
        self.field_name = field_name
        self.field_type = field_type

    def __getattr__(self, name):
        if name == 'select':
            return self.get_type()(self.field_name).select

    def get_type(self):
        if isinstance(self.field_type, ForwardRef):
            return get_type_hints(self.field_type, globals(), locals())
        return self.field_type


@dataclass
class {{ type_ }}(metaclass=GeneratedInterfaceType):
    class OnFragment:
        def __init__(self, on_type: {{ sub_types }}):
            self.on_type = on_type

    {% for field_name, field in type_.fields.items() -%}
        {{ underscore(field_name) }}{{ ': ' }}
        {%- if get_type(field.type, constants.selection).rstrip(']').endswith(constants.selection.value) -%}
            {%- set f_type = get_type(field.type, constants.selection.value + '[' + type_.name + 'Field]', enquote=True, strip_class=True) -%}
            {{ f_type }} = {{ type_ }}Field('{{ field_name }}', {{ f_type }})
        {%- else %}{{ type_ }}Field = {{ type_ }}Field('{{ field_name }}', {{ get_type(field.type, constants.selection, strip_class=True) }}){% endif %}
    {% endfor %}

    {%- for sub_type in type_.types %}
    @staticmethod
    @overload
    def on(on_type: Type[{{ sub_type }}]) -> {{ sub_type }}Selection[Any]: ...
    {% endfor %}
    @staticmethod
    def on(on_type: Union[{% for sub_type in type_.types %}Type[{{ sub_type }}]{% if not loop.last %}, {% endif %}{% endfor %}]):
        return {
            {%- for sub_type in type_.types %}
            {{ sub_type }}: {{ sub_type }}Selection[Any]
            {%- if not loop.last %},{% endif -%}
            {% endfor %}
        }[on_type](None)

{%- endfor %}